<!DOCTYPE html><html lang="zh-cn,en,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>React vNode Diff算法 | 断崖上の风's Blog</title><meta name="description" content="React vNode Diff算法 - 断崖上的风"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dysdf.github.io/atom.xml" title="断崖上の风's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="断崖上の风's Blog" type="application/atom+xml">
</head><body><header><figure style="background-image:url(/image/banner.jpg)" class="site-banner"><div class="site-banner__wrapper"><h3 class="site-banner__title"><a href="/" data-text="断崖上の风's Blog">断崖上の风's Blog</a></h3></div></figure><div class="site-nav"><span class="button-toggle"><span></span></span><div class="nav-list"><div class="nav-item"><a href="/" target="_self" data-text="home">主页</a></div><div class="nav-item"><a href="/archives/" target="_self" data-text="archive">归档</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">关于</a></div></div><form id="search-form" class="nav-item"><label for="local-search-input" class="trigger-btn"><i class="fa fa-search"></i></label><input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" autocomplete="off" autocorrect="off" required class="search form-control"><i id="local-search-reset" onclick="resetSearch()" class="fa fa-close"></i><div id="local-search-result"></div></form></div></header><div class="main"><div class="content"><div class="post-item"><article class="post-article"><div class="post-article__header"><h3 class="post-article__title">React vNode Diff算法</h3><div class="post-article__meta"><span class="post-article__date"><i class="fa fa-calendar"></i><span>2022-01-28</span></span><span href="/categories/%E7%AE%97%E6%B3%95/" class="post-article__category"><i class="fa fa-bookmark"></i><span>算法</span></span><span class="post-article__tags"><i class="fa fa-tags"></i><a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a href="/tags/react/">react</a></span><span class="post-article__review"><i class="fa fa-eye"></i><span><span>阅读次数:</span><span id="busuanzi_value_page_pv">-</span></span></span></div></div><div class="post-content"><blockquote>
<p>用了这么久的MVVM框架，我们都知道MVVM框架相较于jQuery时代，最大的改变就是使用了vNode(虚拟节点)代替了真实的DOM元素做更新，在所有vNode都更新完之后，一次性更新真实DOM元素，防止产生回流重绘。</p>
<p>但是，更新vNode tree也是有代价的，不可能每次更新都是全量更新，而是针对有修改的vNode进行new/patch操作，而怎么确定哪些vNode需要进行更新操作，这就涉及到我们今天要讲的内容：diff算法。</p>
</blockquote>
<span id="more"></span>

<p>本文不讲解vNode的实现、mount挂载及render渲染，只着重讲解算法，下面的diff算法中会出现几个方法，在这里进行罗列，并说明其功能：</p>
<ul>
<li><p><code>mount(vNode, parent, [refNode])</code>: 主要功能是通过vNode生成真实的DOM节点，并插入到parent为父级的真实DOM节点中；refNode为真实的DOM节点，其父级节点也为parent；如果refNode不为空，vNode生成的DOM节点就会插入到refNode之前；如果refNode为空，那么vNode生成的DOM节点就作为最后一个子节点插入到parent中。</p>
</li>
<li><p><code>patch(prevNode, nextNode, parent)</code>: 主要功能是给当前DOM节点进行更新，并且调用diff算法对比自身的子节点;</p>
</li>
</ul>
<h3 id="React-Diff"><a href="#React-Diff" class="headerlink" title="React Diff"></a>React Diff</h3><p>React的思路是递增法。通过对比新列表中的节点在旧列表中的位置是否是递增，来判断当前节点是否需要移动。</p>
<h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p>首先我们看这样一个例子</p>
<p><img src="post_01.png" alt="react diff img 1"></p>
<p>从上图中，我们可以看出，新旧列表没有任何变化，也就是说新列表无需移动任何节点。下面我们用react的递增思想，解释一下为什么新列表中的节点不需要移动。</p>
<p>我们首先遍历<code>new nodes</code>，找到每一个节点在<code>old nodes</code>中的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode === oldNode) &#123;<br>          <span class="hljs-comment">// todo</span><br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>找到位置以后，与上一个节点的位置进行对比。如果当前的位置大于上一个位置，说明当前节点不需要移动；如果小于上一个位置，则需要进行移动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode === oldNode) &#123;<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，<code>new nodes</code>每个节点在<code>old nodes</code>中的位置为<code>0, 1, 2, 3</code>。每一项都要比前一项要大，所以不需要移动，这就是react的diff算法的原理。</p>
<h4 id="2-节点判断"><a href="#2-节点判断" class="headerlink" title="2.节点判断"></a>2.节点判断</h4><p>上面的例子中，我们使用了<code>===</code>来进行节点相同判断，但是在实际框架中，vNode是一个对象，即使数据没有变化也会重新创建，但是在js中，这已经是两个值了。这时我们该如何处理呢？</p>
<p>答案就是<code>key</code>，在生成vNode的时候，我们会分配唯一的key值，以此来确定每个节点的唯一性，并用于进行新旧列表的对比。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-节点移动"><a href="#3-节点移动" class="headerlink" title="3.节点移动"></a>3.节点移动</h4><p>首先明确一点，这里的<code>移动节点</code>指的是移动vNode所对应的真实DOM节点，patch方法会将更新过后的DOM节点，赋值给新的vNode。</p>
<p><img src="post_02.png" alt="react diff img 2"></p>
<p>我们将上图的例子代入<code>reactDiff</code>中执行。</p>
<p>首先遍历<code>new nodes</code>，并查找vNode在<code>old nodes</code>中的位置。当遍历到<code>vNode d</code>时，之前遍历的位置为<code>0 &lt; 2 &lt; 3</code>，说明<code>A C D</code>这三个DOM节点都是不需要移动的。此时<code>lastIndex = 3</code>, 并进入下一次循环，发现<code>vNode b</code>在<code>old nodes</code>中的index为<code>1</code>，小于<code>lastIndex</code>，说明<code>DOM B</code>要移动。</p>
<p>再通过观察我们发现，其实只需要把<code>DOM B</code>移动到<code>DOM D</code>之后就可以了。也就是找到需要移动的vNode，将其对应的真实的DOM节点移动到新列表中的前一个vNode对应的真实DOM的后面即可。</p>
<p><img src="post_03.png" alt="react diff img 3"></p>
<p>在上述的例子中，就是将<code>vNode b</code>对应的真实DOM节点<code>DOM B</code>, 移动到<code>vNode b</code>在新列表中的前一个vNode——<code>vNode d</code>对应的真实DOM节点<code>DOM D</code>的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么是这样移动的呢？因为vNode跟DOM是一一对应的，vNode的顺序就是DOM的顺序，这就意味着对于当前vNode节点来说，它的位置就是DOM节点的位置，如果该节点需要移动，那么只需要将DOM节点移动到前一个vNode节点之后就可以，因为在列表中vNode的顺序就是这样的。</p>
<h4 id="4-节点添加"><a href="#4-节点添加" class="headerlink" title="4.节点添加"></a>4.节点添加</h4><p>前面我们只讲了节点移动，就是新旧列表的元素都是相同的，只是顺序位置有所变化，这一节，我们讲讲在新列表中有全新的vNode节点的情况。</p>
<p>遇到这种情况，我们需要根据新的VNode节点生成DOM节点，并插入DOM树中。</p>
<p>此时，我们面临两个问题：</p>
<ol>
<li>如何发现全新的节点</li>
<li>生成的DOM节点插入到哪里</li>
</ol>
<p><img src="post_04.png" alt="react diff img 4"></p>
<p>先来解决第一个问题，找节点还是比较简单的，我们定义一个<code>existed</code>变量值，初始值为<code>false</code>。如果在旧列表找到了<code>key</code>相同的<code>vNode</code>，就将<code>existed</code>的值改为<code>true</code>。遍历结束后判断<code>existed</code>值，如果为<code>false</code>，说明当前节点为新节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>找到新节点后，接下来就是插入到哪里了。这里的逻辑其实和移动节点的逻辑是一样的。</p>
<p>我们观察上图可以发现，新的<code>vNode c</code>是紧跟在<code>vNode b</code>后面的，所以我们只需要将<code>vNode c</code>的DOM节点插入到<code>vNode b</code>的DOM节点<code>DOM-B</code>之后就可以了。</p>
<p>不过有一种特殊情况需要注意，就是新的节点位于新列表的第一个，这时需要找到旧列表第一个vNode，将新vNode的DOM节点插入到旧列表第一个vNode之前就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-节点删除"><a href="#5-节点删除" class="headerlink" title="5.节点删除"></a>5.节点删除</h4><p>有增就有减，当旧的节点不在新列表中时，我们就需要将其对应的DOM节点移除。</p>
<p>思路就是在进行过新旧节点对比之后，再遍历一遍旧节点列表，如果发现节点不在新列表中，则进行移除操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> oldNode <span class="hljs-keyword">of</span> oldNodes) &#123;<br>    <span class="hljs-keyword">const</span> key = oldNode.<span class="hljs-property">key</span><br>    <span class="hljs-keyword">const</span> has = newNodes.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">key</span> === key);<br>    <span class="hljs-keyword">if</span> (!has) parent.<span class="hljs-title function_">removeChild</span>(oldNode.<span class="hljs-property">el</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-优化与不足"><a href="#6-优化与不足" class="headerlink" title="6.优化与不足"></a>6.优化与不足</h4><p>目前<code>reactDiff</code>的时间复杂度为<code>O(m*n)</code>，主要的时间消耗是在寻找旧节点列表位置上。</p>
<p>对此，我们可以用空间换时间，把<code>vNode</code>与<code>index</code>的关系维护成一个<code>Map</code>，从而将时间复杂度进一步降低，至于能不能达到<code>O(n)</code>，这个就要看<code>Map</code>的实现了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-comment">// preprocess</span><br>  <span class="hljs-keyword">const</span> oldNodeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; oldNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> n = oldNodes[i]<br>    oldNodeMap.<span class="hljs-title function_">set</span>(n.<span class="hljs-property">key</span>, &#123;<br>      <span class="hljs-attr">index</span>: i,<br>      <span class="hljs-attr">node</span>: n<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">const</span> record = oldNodeMap.<span class="hljs-title function_">get</span>(newNode.<span class="hljs-property">key</span>)<br>    <span class="hljs-keyword">if</span> (record) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">node</span>: oldNode, <span class="hljs-attr">index</span>: j &#125; = record<br>      existed = <span class="hljs-literal">true</span><br>      <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>      <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>        <span class="hljs-comment">// need move</span><br>        <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>        parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// do not need move</span><br>        lastIndex = j<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> oldNode <span class="hljs-keyword">of</span> oldNodes) &#123;<br>    <span class="hljs-keyword">const</span> key = oldNode.<span class="hljs-property">key</span><br>    <span class="hljs-keyword">const</span> has = newNodes.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">key</span> === key);<br>    <span class="hljs-keyword">if</span> (!has) parent.<span class="hljs-title function_">removeChild</span>(oldNode.<span class="hljs-property">el</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过，即使这样，react的diff算法仍然存在改进空间。我们看这样一个例子。</p>
<p><img src="post_05.png" alt="react diff img 5"></p>
<p>根据<code>reactDiff</code>的算法，我们需要先将<code>DOM A</code>移动到<code>DOM C</code>之后，然后再将<code>DOM B</code>移动到<code>DOM A</code>之后。</p>
<p>但是通过观察可以发现，其实只要将<code>DOM C</code>移动到<code>DOM A</code>之前就可以完成diff。</p>
<p>这里就是可优化的空间，下一次我们介绍<code>vue2.x</code>中的diff算法：<code>双端比较</code>，该算法解决了上述问题。</p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-next"><a href="/2022/01/17/005.node-detect-tcp-port/" class="next">下一篇<span>Node.js探测TCP端口</span></a></div></div></div><div id="uyan_frame"></div></div><div class="sidebar"><div class="social-links"><ul><li><a href="https://github.com/DYSDF" target="_blank" title="github" class="link-github social-link"><i class="fa fa-github"></i></a></li><li><a href="mailto:admin@duan-ya.com" target="_self" title="邮件" class="link-envelope social-link"><i class="fa fa-envelope"></i></a></li><li><a href="/atom.xml" target="_self" title="订阅" class="link-rss social-link"><i class="fa fa-rss"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title">近期文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/28/006-react-vnode-diff-algorithm/">React vNode Diff算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/17/005.node-detect-tcp-port/">Node.js探测TCP端口</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/29/004.nginx-proxy-websocket/">使用 Nginx 对 WebSocket 做反向代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/29/003.websocket/">WebSocket 简单介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/27/002.browser_architecture_evolution/">浏览器架构演进</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title">近期评论</h3><div class="widget-content"><div id="uyan_newcmt_unit"></div></div></div><div class="tag-lists widget"><h3 class="widget-title">标签</h3><div class="widget-content"><div id="tags-ball"><canvas></canvas></div></div></div><div class="archive-lists widget"><h3 class="widget-title">归档</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">4</span></li></ul></div></div></div></div><footer><div class="copyright"><div class="col-6"><div class="site-info">© 2016 - 2024 <span class="icon icon-heart"></span> <a href="https://dysdf.github.io">断崖上的风</a><span class="sep">/</span><a href="https://hexo.io/" target="_blank">Powered by Hexo</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li><a href="https://github.com/DYSDF" target="_blank" title="github" class="link-github social-link"><i class="fa fa-github"></i></a></li><li><a href="mailto:admin@duan-ya.com" target="_self" title="邮件" class="link-envelope social-link"><i class="fa fa-envelope"></i></a></li><li><a href="/atom.xml" target="_self" title="订阅" class="link-rss social-link"><i class="fa fa-rss"></i></a></li></ul></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script><script src="/js/tags_ball.js"></script><script>$.initTags(document.querySelector('#tags-ball canvas'), [{"name":"计算机","href":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"操作系统","href":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","href":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","href":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"浏览器","href":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"前端","href":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"WebSocket","href":"/tags/WebSocket/"},{"name":"HTML5","href":"/tags/HTML5/"},{"name":"Nginx","href":"/tags/Nginx/"},{"name":"Node.js","href":"/tags/Node-js/"},{"name":"TCP","href":"/tags/TCP/"},{"name":"算法","href":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"react","href":"/tags/react/"}])
</script><!-- busuanzi--><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>