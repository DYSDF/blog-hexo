<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>断崖上の风&#39;s Blog</title>
  
  
  <link href="https://dysdf.github.io/atom.xml" rel="self"/>
  
  <link href="https://dysdf.github.io/"/>
  <updated>2024-10-12T13:54:01.686Z</updated>
  <id>https://dysdf.github.io/</id>
  
  <author>
    <name>断崖上的风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React vNode Diff算法</title>
    <link href="https://dysdf.github.io/2022/01/28/006-react-vnode-diff-algorithm/"/>
    <id>https://dysdf.github.io/2022/01/28/006-react-vnode-diff-algorithm/</id>
    <published>2022-01-28T12:34:48.000Z</published>
    <updated>2024-10-12T13:54:01.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用了这么久的MVVM框架，我们都知道MVVM框架相较于jQuery时代，最大的改变就是使用了vNode(虚拟节点)代替了真实的DOM元素做更新，在所有vNode都更新完之后，一次性更新真实DOM元素，防止产生回流重绘。</p><p>但是，更新vNode tree也是有代价的，不可能每次更新都是全量更新，而是针对有修改的vNode进行new/patch操作，而怎么确定哪些vNode需要进行更新操作，这就涉及到我们今天要讲的内容：diff算法。</p></blockquote><span id="more"></span><p>本文不讲解vNode的实现、mount挂载及render渲染，只着重讲解算法，下面的diff算法中会出现几个方法，在这里进行罗列，并说明其功能：</p><ul><li><p><code>mount(vNode, parent, [refNode])</code>: 主要功能是通过vNode生成真实的DOM节点，并插入到parent为父级的真实DOM节点中；refNode为真实的DOM节点，其父级节点也为parent；如果refNode不为空，vNode生成的DOM节点就会插入到refNode之前；如果refNode为空，那么vNode生成的DOM节点就作为最后一个子节点插入到parent中。</p></li><li><p><code>patch(prevNode, nextNode, parent)</code>: 主要功能是给当前DOM节点进行更新，并且调用diff算法对比自身的子节点;</p></li></ul><h3 id="React-Diff"><a href="#React-Diff" class="headerlink" title="React Diff"></a>React Diff</h3><p>React的思路是递增法。通过对比新列表中的节点在旧列表中的位置是否是递增，来判断当前节点是否需要移动。</p><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p>首先我们看这样一个例子</p><p><img src="post_01.png" alt="react diff img 1"></p><p>从上图中，我们可以看出，新旧列表没有任何变化，也就是说新列表无需移动任何节点。下面我们用react的递增思想，解释一下为什么新列表中的节点不需要移动。</p><p>我们首先遍历<code>new nodes</code>，找到每一个节点在<code>old nodes</code>中的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode === oldNode) &#123;<br>          <span class="hljs-comment">// todo</span><br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到位置以后，与上一个节点的位置进行对比。如果当前的位置大于上一个位置，说明当前节点不需要移动；如果小于上一个位置，则需要进行移动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode === oldNode) &#123;<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>new nodes</code>每个节点在<code>old nodes</code>中的位置为<code>0, 1, 2, 3</code>。每一项都要比前一项要大，所以不需要移动，这就是react的diff算法的原理。</p><h4 id="2-节点判断"><a href="#2-节点判断" class="headerlink" title="2.节点判断"></a>2.节点判断</h4><p>上面的例子中，我们使用了<code>===</code>来进行节点相同判断，但是在实际框架中，vNode是一个对象，即使数据没有变化也会重新创建，但是在js中，这已经是两个值了。这时我们该如何处理呢？</p><p>答案就是<code>key</code>，在生成vNode的时候，我们会分配唯一的key值，以此来确定每个节点的唯一性，并用于进行新旧列表的对比。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-节点移动"><a href="#3-节点移动" class="headerlink" title="3.节点移动"></a>3.节点移动</h4><p>首先明确一点，这里的<code>移动节点</code>指的是移动vNode所对应的真实DOM节点，patch方法会将更新过后的DOM节点，赋值给新的vNode。</p><p><img src="post_02.png" alt="react diff img 2"></p><p>我们将上图的例子代入<code>reactDiff</code>中执行。</p><p>首先遍历<code>new nodes</code>，并查找vNode在<code>old nodes</code>中的位置。当遍历到<code>vNode d</code>时，之前遍历的位置为<code>0 &lt; 2 &lt; 3</code>，说明<code>A C D</code>这三个DOM节点都是不需要移动的。此时<code>lastIndex = 3</code>, 并进入下一次循环，发现<code>vNode b</code>在<code>old nodes</code>中的index为<code>1</code>，小于<code>lastIndex</code>，说明<code>DOM B</code>要移动。</p><p>再通过观察我们发现，其实只需要把<code>DOM B</code>移动到<code>DOM D</code>之后就可以了。也就是找到需要移动的vNode，将其对应的真实的DOM节点移动到新列表中的前一个vNode对应的真实DOM的后面即可。</p><p><img src="post_03.png" alt="react diff img 3"></p><p>在上述的例子中，就是将<code>vNode b</code>对应的真实DOM节点<code>DOM B</code>, 移动到<code>vNode b</code>在新列表中的前一个vNode——<code>vNode d</code>对应的真实DOM节点<code>DOM D</code>的后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么是这样移动的呢？因为vNode跟DOM是一一对应的，vNode的顺序就是DOM的顺序，这就意味着对于当前vNode节点来说，它的位置就是DOM节点的位置，如果该节点需要移动，那么只需要将DOM节点移动到前一个vNode节点之后就可以，因为在列表中vNode的顺序就是这样的。</p><h4 id="4-节点添加"><a href="#4-节点添加" class="headerlink" title="4.节点添加"></a>4.节点添加</h4><p>前面我们只讲了节点移动，就是新旧列表的元素都是相同的，只是顺序位置有所变化，这一节，我们讲讲在新列表中有全新的vNode节点的情况。</p><p>遇到这种情况，我们需要根据新的VNode节点生成DOM节点，并插入DOM树中。</p><p>此时，我们面临两个问题：</p><ol><li>如何发现全新的节点</li><li>生成的DOM节点插入到哪里</li></ol><p><img src="post_04.png" alt="react diff img 4"></p><p>先来解决第一个问题，找节点还是比较简单的，我们定义一个<code>existed</code>变量值，初始值为<code>false</code>。如果在旧列表找到了<code>key</code>相同的<code>vNode</code>，就将<code>existed</code>的值改为<code>true</code>。遍历结束后判断<code>existed</code>值，如果为<code>false</code>，说明当前节点为新节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到新节点后，接下来就是插入到哪里了。这里的逻辑其实和移动节点的逻辑是一样的。</p><p>我们观察上图可以发现，新的<code>vNode c</code>是紧跟在<code>vNode b</code>后面的，所以我们只需要将<code>vNode c</code>的DOM节点插入到<code>vNode b</code>的DOM节点<code>DOM-B</code>之后就可以了。</p><p>不过有一种特殊情况需要注意，就是新的节点位于新列表的第一个，这时需要找到旧列表第一个vNode，将新vNode的DOM节点插入到旧列表第一个vNode之前就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-节点删除"><a href="#5-节点删除" class="headerlink" title="5.节点删除"></a>5.节点删除</h4><p>有增就有减，当旧的节点不在新列表中时，我们就需要将其对应的DOM节点移除。</p><p>思路就是在进行过新旧节点对比之后，再遍历一遍旧节点列表，如果发现节点不在新列表中，则进行移除操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldNodes.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> oldNode = oldNodes[j]<br>        <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">key</span> === oldNode.<span class="hljs-property">key</span>) &#123;<br>          existed = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>          <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>            <span class="hljs-comment">// need move</span><br>            <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>            parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// do not need move</span><br>            lastIndex = j<br>          &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> oldNode <span class="hljs-keyword">of</span> oldNodes) &#123;<br>    <span class="hljs-keyword">const</span> key = oldNode.<span class="hljs-property">key</span><br>    <span class="hljs-keyword">const</span> has = newNodes.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">key</span> === key);<br>    <span class="hljs-keyword">if</span> (!has) parent.<span class="hljs-title function_">removeChild</span>(oldNode.<span class="hljs-property">el</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-优化与不足"><a href="#6-优化与不足" class="headerlink" title="6.优化与不足"></a>6.优化与不足</h4><p>目前<code>reactDiff</code>的时间复杂度为<code>O(m*n)</code>，主要的时间消耗是在寻找旧节点列表位置上。</p><p>对此，我们可以用空间换时间，把<code>vNode</code>与<code>index</code>的关系维护成一个<code>Map</code>，从而将时间复杂度进一步降低，至于能不能达到<code>O(n)</code>，这个就要看<code>Map</code>的实现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactDiff</span>(<span class="hljs-params">newNodes, oldNodes, parent</span>) &#123;<br>  <span class="hljs-comment">// preprocess</span><br>  <span class="hljs-keyword">const</span> oldNodeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; oldNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> n = oldNodes[i]<br>    oldNodeMap.<span class="hljs-title function_">set</span>(n.<span class="hljs-property">key</span>, &#123;<br>      <span class="hljs-attr">index</span>: i,<br>      <span class="hljs-attr">node</span>: n<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newNodes.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> newNode = newNodes[i];<br>    <span class="hljs-keyword">let</span> existed = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">const</span> record = oldNodeMap.<span class="hljs-title function_">get</span>(newNode.<span class="hljs-property">key</span>)<br>    <span class="hljs-keyword">if</span> (record) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">node</span>: oldNode, <span class="hljs-attr">index</span>: j &#125; = record<br>      existed = <span class="hljs-literal">true</span><br>      <span class="hljs-title function_">patch</span>(oldNode, newNode, parent)<br>      <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>        <span class="hljs-comment">// need move</span><br>        <span class="hljs-keyword">const</span> refNode = newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>;<br>        parent.<span class="hljs-title function_">insertBefore</span>(newNode.<span class="hljs-property">el</span>, refNode)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// do not need move</span><br>        lastIndex = j<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (existed) &#123;<br>      <span class="hljs-comment">// need create</span><br>      <span class="hljs-keyword">const</span> refNode = i &lt;= <span class="hljs-number">0</span><br>        ? oldNodes[<span class="hljs-number">0</span>].<span class="hljs-property">el</span><br>        : newNodes[i - <span class="hljs-number">1</span>].<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      <span class="hljs-title function_">mount</span>(newNode, parent, refNode);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> oldNode <span class="hljs-keyword">of</span> oldNodes) &#123;<br>    <span class="hljs-keyword">const</span> key = oldNode.<span class="hljs-property">key</span><br>    <span class="hljs-keyword">const</span> has = newNodes.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">key</span> === key);<br>    <span class="hljs-keyword">if</span> (!has) parent.<span class="hljs-title function_">removeChild</span>(oldNode.<span class="hljs-property">el</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，即使这样，react的diff算法仍然存在改进空间。我们看这样一个例子。</p><p><img src="post_05.png" alt="react diff img 5"></p><p>根据<code>reactDiff</code>的算法，我们需要先将<code>DOM A</code>移动到<code>DOM C</code>之后，然后再将<code>DOM B</code>移动到<code>DOM A</code>之后。</p><p>但是通过观察可以发现，其实只要将<code>DOM C</code>移动到<code>DOM A</code>之前就可以完成diff。</p><p>这里就是可优化的空间，下一次我们介绍<code>vue2.x</code>中的diff算法：<code>双端比较</code>，该算法解决了上述问题。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;用了这么久的MVVM框架，我们都知道MVVM框架相较于jQuery时代，最大的改变就是使用了vNode(虚拟节点)代替了真实的DOM元素做更新，在所有vNode都更新完之后，一次性更新真实DOM元素，防止产生回流重绘。&lt;/p&gt;
&lt;p&gt;但是，更新vNode tree也是有代价的，不可能每次更新都是全量更新，而是针对有修改的vNode进行new/patch操作，而怎么确定哪些vNode需要进行更新操作，这就涉及到我们今天要讲的内容：diff算法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="https://dysdf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前端" scheme="https://dysdf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="算法" scheme="https://dysdf.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="react" scheme="https://dysdf.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Node.js探测TCP端口</title>
    <link href="https://dysdf.github.io/2022/01/17/005.node-detect-tcp-port/"/>
    <id>https://dysdf.github.io/2022/01/17/005.node-detect-tcp-port/</id>
    <published>2022-01-17T16:53:28.000Z</published>
    <updated>2024-10-12T13:54:01.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在网络技术中，端口(Port)大致有两种意思：</p><ul><li>物理意义上的端口：比如，ADSL Modem/集线器/交换机/路由器上用于连接其他网络设备的接口，如RJ-45端口、SC端口等等</li><li>逻辑意义上的端口：一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80/443。</li></ul></blockquote><p>而在实际开发过程中，经常遇到一些关于跟端口有关的问题，比如运行服务时提示：端口已被占用。</p><p>这篇文章的目的是为了解决运行服务的时候端口被占用的情况，通过代码来检测某个端口是否已经被占用，也是目前进行端口探测的主要手段。</p><span id="more"></span><p>下面跟大家分享研究的代码片段，有需要的可以参考借鉴。</p><h3 id="通过服务监听的方式"><a href="#通过服务监听的方式" class="headerlink" title="通过服务监听的方式"></a>通过服务监听的方式</h3><p>原理就是创建一个web服务，然后监听指定端口，通过能否监听指定端口来判断是否已经被其它服务占用。</p><p>这种方式有点像“以毒攻毒”，既然监听端口可能会出现端口被占用的情况，那也可以用来判断这个端口是否可用的依据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> detector = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Server</span>()<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this port is available`</span>)<br>  detector.<span class="hljs-title function_">close</span>(<span class="hljs-literal">true</span>)<br>&#125;)<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;EADDRINUSE&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this port is not available&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">throw</span> err<br>&#125;)<br>detector.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><p>不过，这个方法的缺点也是有的，通过创建服务监听端口的方式会影响正常服务的创建</p><p>下面的代码，web服务一定无法启动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> detector = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Server</span>()<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this port is available`</span>)<br>  detector.<span class="hljs-title function_">close</span>(<span class="hljs-literal">true</span>)<br>&#125;)<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;EADDRINUSE&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this port is not available&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">throw</span> err<br>&#125;)<br>detector.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">const</span> web = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Server</span>()<br>web.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;web server is available&#x27;</span>)<br>&#125;)<br>web.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;web server has error&#x27;</span>, err)<br>&#125;)<br>web.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><h3 id="通过Socket连接方式"><a href="#通过Socket连接方式" class="headerlink" title="通过Socket连接方式"></a>通过Socket连接方式</h3><p>既然通过端口监听的方式可能会造成正常服务无法启动，那我们换一种思路。即不通过提供服务的方式，而是通过客户端连接的方式来判断指定端口是否可用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> detector = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Socket</span>()<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this port is not available`</span>)<br>  detector.<span class="hljs-title function_">destroy</span>()<br>&#125;)<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;ECONNREFUSED&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this port is available&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">throw</span> err<br>&#125;)<br>detector.<span class="hljs-title function_">connect</span>(<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><p>这种方式就是把自己当成客户端，然后去尝试连接指点端口，如果能成功建立socket连接，那这个端口一定被其它服务占用了，否则端口可用。</p><p>而且，这种方式也不会造成正常服务启动受阻，可以说十分可靠。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> detector = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Socket</span>()<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this port is not available`</span>)<br>  detector.<span class="hljs-title function_">destroy</span>()<br>&#125;)<br>detector.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;ECONNREFUSED&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this port is available&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">throw</span> err<br>&#125;)<br>detector.<span class="hljs-title function_">connect</span>(<span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">const</span> web = <span class="hljs-keyword">new</span> net.<span class="hljs-title class_">Server</span>()<br>web.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;web server is available&#x27;</span>)<br>&#125;)<br>web.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;web server has error&#x27;</span>, err)<br>&#125;)<br>web.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>端口探测基本就是两种方式，一种通过创建服务监听端口的方式，一种是模拟客户端进行连接方式。</p><p>从实用性角度上来说，推荐大家使用第二种，因为第一种存在阻碍正常服务启动的可能性。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在网络技术中，端口(Port)大致有两种意思：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理意义上的端口：比如，ADSL Modem/集线器/交换机/路由器上用于连接其他网络设备的接口，如RJ-45端口、SC端口等等&lt;/li&gt;
&lt;li&gt;逻辑意义上的端口：一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80/443。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;而在实际开发过程中，经常遇到一些关于跟端口有关的问题，比如运行服务时提示：端口已被占用。&lt;/p&gt;
&lt;p&gt;这篇文章的目的是为了解决运行服务的时候端口被占用的情况，通过代码来检测某个端口是否已经被占用，也是目前进行端口探测的主要手段。&lt;/p&gt;</summary>
    
    
    
    <category term="Node.js" scheme="https://dysdf.github.io/categories/Node-js/"/>
    
    
    <category term="Node.js" scheme="https://dysdf.github.io/tags/Node-js/"/>
    
    <category term="TCP" scheme="https://dysdf.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 对 WebSocket 做反向代理</title>
    <link href="https://dysdf.github.io/2021/09/29/004.nginx-proxy-websocket/"/>
    <id>https://dysdf.github.io/2021/09/29/004.nginx-proxy-websocket/</id>
    <published>2021-09-29T09:03:12.000Z</published>
    <updated>2024-10-12T13:54:01.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Websocket 协议为客户端与服务端相互通信提供了一种方式，因为其基于 HTTP 协议扩展而来，所以 WebSocket 的握手和 HTTP 中的握手兼容，通过使用 HTTP 中的 Upgrade 协议头将连接从 HTTP 升级到 WebSocket。这使得 WebSocket 程序可以更容易的使用现已存在的网络基础设施。</p></blockquote><p>通常在实际的生产环境中，为保证 HTTP 服务具有高性能和高可用，一般使用 Nginx 作为负载均衡层。而 Nginx 从1.3版本开始支持 WebSocket，其可以为 WebSocket 服务做代理和负载均衡。这篇文章将对反代传统 HTTP 服务的 Nginx 配置进行一些修改调整，使其支持后端的 Websocket 服务。</p><p>关于 Websocket 的更多介绍可参考<a href="/2021/09/29/003.websocket/" title="WebSocket 简单介绍">我之前的文章</a>。</p><span id="more"></span><h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><p>这是最简单的、可以代理 WebSocket 的配置，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">location /ws/ &#123;<br>  proxy_pass http://backend_server;<br>  proxy_http_version 1.1;<br>  proxy_set_header Upgrade $http_upgrade;<br>  proxy_set_header Connection &quot;upgrade&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过配置可以看出，对所有的请求都会附带上 Connection=Upgrade 的请求头，这对于 WebSocket 来说是必要的，因为它需要借助 HTTP 进行协议升级，但是对于普通的 HTTP 请求来说，它是多余的。</p><p>所以使用这个配置，如果代理的连接都为 WebSocket 协议是没有问题的，但是通常我们的 WebSocket 服务都是作为 HTTP 服务的一部分存在的，不会单独有自己的域名地址或服务器。</p><p>这就需要我们改造现有的配置，使其既能支持 HTTP，也能支持WebSocket。</p><h3 id="兼容配置"><a href="#兼容配置" class="headerlink" title="兼容配置"></a>兼容配置</h3><p>通过对 Nginx 官方文档的阅读，我们知道了 map 指令，通过它，就可以做到既支持 ws 请求，又支持 http 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">map $http_upgrade $connection_upgrade &#123;<br>  default upgrade;<br>  &#x27;&#x27;      close;<br>&#125;<br><br>server &#123;<br>  ...<br><br>  location /ws/ &#123;<br>    proxy_pass http://backend_server;<br>    proxy_http_version 1.1;<br>    proxy_set_header Upgrade $http_upgrade;<br>    proxy_set_header Connection $connection_upgrade;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意增加的配置部分，最重要的是对 <code>Connection Header</code> 进行了<code>动态取值</code>，它不再是<code>固定值“upgrade”</code>，其它的部分和普通的HTTP反向代理没有任何差别。</p><p>原理就是通过 Nginx 的 <code>map</code> 指令，根据 HTTP 请求中是否存在 <code>Upgrade Header</code> 来决定 <code>Connection</code> 是否要取值“upgrade”，也就是这个连接是否要进行协议升级。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://nginx.org/en/docs/http/websocket.html">WebSocket proxying</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Websocket 协议为客户端与服务端相互通信提供了一种方式，因为其基于 HTTP 协议扩展而来，所以 WebSocket 的握手和 HTTP 中的握手兼容，通过使用 HTTP 中的 Upgrade 协议头将连接从 HTTP 升级到 WebSocket。这使得 WebSocket 程序可以更容易的使用现已存在的网络基础设施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常在实际的生产环境中，为保证 HTTP 服务具有高性能和高可用，一般使用 Nginx 作为负载均衡层。而 Nginx 从1.3版本开始支持 WebSocket，其可以为 WebSocket 服务做代理和负载均衡。这篇文章将对反代传统 HTTP 服务的 Nginx 配置进行一些修改调整，使其支持后端的 Websocket 服务。&lt;/p&gt;
&lt;p&gt;关于 Websocket 的更多介绍可参考&lt;a href=&quot;/2021/09/29/003.websocket/&quot; title=&quot;WebSocket 简单介绍&quot;&gt;我之前的文章&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://dysdf.github.io/categories/Nginx/"/>
    
    
    <category term="WebSocket" scheme="https://dysdf.github.io/tags/WebSocket/"/>
    
    <category term="Nginx" scheme="https://dysdf.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket 简单介绍</title>
    <link href="https://dysdf.github.io/2021/09/29/003.websocket/"/>
    <id>https://dysdf.github.io/2021/09/29/003.websocket/</id>
    <published>2021-09-29T04:26:33.000Z</published>
    <updated>2024-10-12T13:54:01.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>WebSocket</code> 是一种网络传输协议，可在单个 <code>TCP</code> 连接上进行<code>全双工</code>通信，位于<code>OSI</code>模型的应用层。<code>WebSocket</code>中的握手和<code>HTTP</code>中的握手兼容，使用<code>HTTP</code>中的<code>Upgrade</code>协议头将连接从<code>HTTP</code>升级到<code>WebSocket</code>，这使得<code>WebSocket</code>程序可以更容易的使用现已存在的基础设施。<code>WebSocket</code>协议相比较于<code>HTTP</code>协议成功握手后可以多次进行通讯，直到连接被关闭。</p></blockquote><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebSocket 是目前比较成熟的技术了，WebSocket 协议为客户端和服务器端之间的实时双向通讯提供了一个选择。其作为 HTML5 的一部分，已经成为国际标准，几乎所有的现代浏览器都已经支持 WebSocket，比如 Firefox，IE，Chrome，Safari，Opera，并且越来越多的服务器框架也支持 WebSocket。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p><img src="ws_vs_http.png" alt="WebSocket对比HTTP"></p><p>其它特点包括：</p><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口同样是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li></ul><p><img src="ws_vs_http_2.jpg" alt="WebSocket对比HTTP"></p><h3 id="旧时代的“服务端推送”"><a href="#旧时代的“服务端推送”" class="headerlink" title="旧时代的“服务端推送”"></a>旧时代的“服务端推送”</h3><p>在 WebSocket 出现以前，为了实现“服务器推送”，我们一般采用“长连接” + “轮询”的实现方式。即客户端向服务发起 HTTP 请求，服务器收到请求后不立即响应，而是让连接一直处于挂起状态，等到需要向客户端“推送”消息了，再响应这个连接；客户端收到服务端的 HTTP 响应后，这个 HTTP 连接就断开了，所以客户端就再次发起一个 HTTP 请求，服务端收到后再挂起，如此往复。行为类似于我们小时候玩的<code>“纸杯电话”</code>。</p><p>这种方式虽然也能实现服务端的“推送”，但是存在如下致命问题：</p><ul><li>非全双工通信，同一时刻只能由一端进行数据发送，无法同时进行。</li><li>客户端和服务端的每一次通信都要建立一次 TCP 连接，而且无法复用链路，在限制 TCP 连接数的浏览器上，可能会导致正常的 HTTP 请求无法发出。</li><li>每次 HTTP 握手也要消耗时间，而且每次通信除了真正的数据部分外，还会携带大量 HTTP Header，信息交换效率极低。</li></ul><h3 id="新时代的-WebSocket"><a href="#新时代的-WebSocket" class="headerlink" title="新时代的 WebSocket"></a>新时代的 WebSocket</h3><p>相对于传统 HTTP 每次<code>请求-应答</code>都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接通讯模式。一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><p>对比 HTTP 长连接，WebSocket有如下优点：</p><ul><li>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。</li><li>Websocket 通过第一个 request 建立了 TCP 连接之后，之后交换的数据都不需要发送 HTTP header 就能交换数据。此外还有<code>多路复用(multiplexing)</code>，不同的URL可以复用同一个WebSocket 连接等功能。</li></ul><p>这些都是 HTTP 长连接所不具备的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>WebSocket 与 HTTP 相同点</strong></p><ul><li>都是基于 TCP 协议的，都是可靠性传输协议。</li><li>都是应用层协议。</li></ul><p><strong>WebSocket 与 HTTP 不同点</strong></p><ul><li>WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向的。</li><li>WebSocket 是需要浏览器和服务器握手进行建立连接的。而 HTTP 是浏览器向服务器发起的连接，服务器预先并不知道这个连接。</li></ul><p><strong>WebSocket 与 HTTP 联系</strong><br>在 WebSocket中，客户端和服务端在建立连接之前，是需要通过 HTTP 协议进行一个握手的动作，握手时，数据是通过 HTTP 传输的。但是握手完成之后，会单独建立一条 TCP 的通信通道进行数据的传送，所以在真正传输时候是不需要 HTTP 协议的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSocket&lt;/code&gt; 是一种网络传输协议，可在单个 &lt;code&gt;TCP&lt;/code&gt; 连接上进行&lt;code&gt;全双工&lt;/code&gt;通信，位于&lt;code&gt;OSI&lt;/code&gt;模型的应用层。&lt;code&gt;WebSocket&lt;/code&gt;中的握手和&lt;code&gt;HTTP&lt;/code&gt;中的握手兼容，使用&lt;code&gt;HTTP&lt;/code&gt;中的&lt;code&gt;Upgrade&lt;/code&gt;协议头将连接从&lt;code&gt;HTTP&lt;/code&gt;升级到&lt;code&gt;WebSocket&lt;/code&gt;，这使得&lt;code&gt;WebSocket&lt;/code&gt;程序可以更容易的使用现已存在的基础设施。&lt;code&gt;WebSocket&lt;/code&gt;协议相比较于&lt;code&gt;HTTP&lt;/code&gt;协议成功握手后可以多次进行通讯，直到连接被关闭。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="WebSocket" scheme="https://dysdf.github.io/categories/WebSocket/"/>
    
    
    <category term="前端" scheme="https://dysdf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="WebSocket" scheme="https://dysdf.github.io/tags/WebSocket/"/>
    
    <category term="HTML5" scheme="https://dysdf.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>浏览器架构演进</title>
    <link href="https://dysdf.github.io/2021/09/27/002.browser_architecture_evolution/"/>
    <id>https://dysdf.github.io/2021/09/27/002.browser_architecture_evolution/</id>
    <published>2021-09-27T10:00:11.000Z</published>
    <updated>2024-10-12T13:54:01.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>身为常与浏览器共舞的Web工程师，尤其是Frontend Engineer，如果有一天浏览器突然消失了，应该要就地转行了吧😂。<br>  不过你知道浏览器为什么会变得越来越强呢？透过这篇文章，我想浅浅得介绍下浏览器的架构演进史。<br>  身为Web工程师，浏览器与我们密不可分。但除了学会使用它以外，如果能去理解背后的运作模式，我认为是百利而无一害的。除了学会根据背后运作模式去建构更好的web应用以外，也可以提早洞察到未来可能的发展，领先其他人一步去探索更多可能性。<br>  <code>进程(process)</code>/<code>线程(thread)</code>是两个必备的知识点，如果还不太了解两者概念的读者可以参考<a href="/2021/09/27/001.process_and_thread/" title="线程与进程的简单解释">我之前的文章</a>。</p></blockquote><span id="more"></span><h3 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h3><p>在2007年之前，市面上的浏览器基本都是单进程(Single Process)单一程序架构的，即浏览器的网络线程、渲染线程、js环境等都是运行在同一个浏览器进程里面。</p><p><img src="single_process_browser.png" alt="单进程浏览器架构"></p><p>这样的架构存在下面几个问题：</p><ul><li><strong>不稳定</strong>：某一线程崩溃(特别是第三方插件和JS环境)，都会导致整个进程崩溃，最终就是整个浏览器崩溃。</li><li><strong>不安全</strong>：线程之间都是共享系统资源，所以导致插件或者JS脚本可能获取到浏览器隐私数据，造成信息安全，关键无法防护。</li><li><strong>不流畅</strong>：同一时刻只能运行一个线程，某一线程如果出现死循环(比如JS环境)，则整个浏览器处于卡死状态。</li></ul><p>以上就是单进程浏览器的最大缺陷，单进程架构下的浏览器只是达到了能用，但并不好用。</p><p>你能想象在你写完了长篇博文，还没来得及提交，就因为你去另一个页面点击了下一曲，导致整个浏览器崩溃，而导致你的努力全部白费的痛苦么？</p><h3 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h3><p>自从chrome发布后，IE就被扫进了垃圾堆。那么原因是什么？能让消费者用脚投票让谷歌干翻微软，甚至Edge也直接使用chromium内核。</p><p>这是一张早期chrome架构图：</p><p><img src="chrome_early_framework.jpg" alt="早期chrome架构"></p><p>可以看到，chrome把最容易引起问题的两个模块独立成了单独进程，完美解决了单进程浏览器的问题。</p><ul><li><strong>不稳定问题</strong>：让插件、渲染进程相互隔离，当一个页面的插件或者渲染崩溃时，影响的仅仅是当前页面的进程或者插件进程，并不影响其它页面。</li><li><strong>不安全问题</strong>：因为进程独立，插件和渲染进程无法相互访问数据，并通过因为<code>沙盒(Sandbox)</code>机制，使得插件和渲染进程访问系统数据受到了严格限制，即使存在恶意代码，也无法透过沙盒影响外部。</li><li><strong>不流畅问题</strong>：这种架构下，每个页面的渲染都是在独立的进程下，任何页面的渲染瓶颈也只能影响自身页面；而且通过多进程还可以最大化利用CPU多核性能，进一步提高了流畅度。</li></ul><p>chrome仅仅通过架构上的调整，就解决了单进程浏览器的致命问题，现在看IE被扫进垃圾堆里一点都不冤。</p><p>但多进程也不是银弹，作为代价不可避免的带来了一些新的问题：</p><ul><li><strong>更高的资源占用</strong>：因为每个进程都有独立的系统资源，这就意味着多进程浏览器相对于单进程浏览器会消耗更多的资源(比如内存)。</li><li><strong>更复杂的架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h3 id="面向未来的浏览器"><a href="#面向未来的浏览器" class="headerlink" title="面向未来的浏览器"></a>面向未来的浏览器</h3><p>在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务。</p><p><img src="chrome_soa_framework.png" alt="Chrome SOA 架构"></p><p>虽然说是面向面来，但 Chrome 团队已经在逐步往这套架构演进，为什么这么说，接着往下看。不过虽然 Chrome 已经开始改造了，但是现阶段仍处于迭代过渡的截断。</p><h3 id="当前的多进程浏览器"><a href="#当前的多进程浏览器" class="headerlink" title="当前的多进程浏览器"></a>当前的多进程浏览器</h3><p><em><strong>以下内容完全基于chrome浏览器</strong></em></p><p>在开始之前，我们一起看下，Chrome打开一个页面需要启动多少进程？</p><p>你可以点击Chrome浏览器右上角的“<code>选项</code>”菜单，选择“<code>更多工具</code>”，点击“<code>任务管理器</code>”，这将打开Chrome的任务管理器的窗口，如下图：</p><p><img src="chrome_task_panel.png" alt="chrome任务管理器"></p><p>哇！好多进程！！！但通过观察，其实主要分为以下几类进程：</p><ul><li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为<code>每个Tab</code>标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU进程</strong>：Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现<code>3D CSS</code>的效果，只是随后网页、Chrome的 UI 界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li><li><strong>Network Service</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>Audio Service</strong>：主要用于处理音频。</li><li><strong>Storage Service</strong>:主要用于处理本地数据存储，包括Storage、Cache</li></ul><h3 id="为什么仍会出现某个页面崩溃导致其它页面一起崩溃的情况？"><a href="#为什么仍会出现某个页面崩溃导致其它页面一起崩溃的情况？" class="headerlink" title="为什么仍会出现某个页面崩溃导致其它页面一起崩溃的情况？"></a>为什么仍会出现某个页面崩溃导致其它页面一起崩溃的情况？</h3><p><img src="chrome_crash.png" alt="Chrome Crash"></p><p>按照前面的说法，每个页面都有自己独立的功能模块进程，但是为什么还是会出现一个页面崩溃导致其它页面跟着崩溃的情况？这里就要引出Chrome的<code>渲染进程策略</code>了。</p><p>默认情况下，每个标签对应一个渲染进程，但是如果从当前页面打开了新的页面，而新的页面又与当前页面属于同一站点的话，那么Chrome就会复用当前页面的渲染进程。</p><p>如果新的页面跟当前页面不属于同一站点，那么新的页面就会产生新的渲染进程。</p><p>因此，当多个页面属于同一站点，共享一个渲染进程，当某个页面崩溃的时候，也将导致同一站点的其他页面也崩溃。这也就是Chrome任务管理器下会出现某些页面没有资源使用情况的原因。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>单进程浏览器实现了人们对 Web 访问的需求，但是架构上先天存在<strong>不稳定</strong>、<strong>不流畅</strong>、<strong>不安全</strong>的问题。</li><li>多进程浏览器的出现终结了单进程浏览器，但是也导致了<strong>更高的资源占用</strong>、<strong>更复杂的架构体系</strong>等问题。</li><li>SOA是面向未来的浏览器架构，目的是构建一个<strong>高内聚</strong>、<strong>低耦合</strong>、<strong>易于维护和扩展</strong>的系统，现已逐步实现。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;身为常与浏览器共舞的Web工程师，尤其是Frontend Engineer，如果有一天浏览器突然消失了，应该要就地转行了吧😂。&lt;br&gt;  不过你知道浏览器为什么会变得越来越强呢？透过这篇文章，我想浅浅得介绍下浏览器的架构演进史。&lt;br&gt;  身为Web工程师，浏览器与我们密不可分。但除了学会使用它以外，如果能去理解背后的运作模式，我认为是百利而无一害的。除了学会根据背后运作模式去建构更好的web应用以外，也可以提早洞察到未来可能的发展，领先其他人一步去探索更多可能性。&lt;br&gt;  &lt;code&gt;进程(process)&lt;/code&gt;/&lt;code&gt;线程(thread)&lt;/code&gt;是两个必备的知识点，如果还不太了解两者概念的读者可以参考&lt;a href=&quot;/2021/09/27/001.process_and_thread/&quot; title=&quot;线程与进程的简单解释&quot;&gt;我之前的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://dysdf.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="进程" scheme="https://dysdf.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://dysdf.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="浏览器" scheme="https://dysdf.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="前端" scheme="https://dysdf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>线程与进程的简单解释</title>
    <link href="https://dysdf.github.io/2021/09/27/001.process_and_thread/"/>
    <id>https://dysdf.github.io/2021/09/27/001.process_and_thread/</id>
    <published>2021-09-27T08:24:20.000Z</published>
    <updated>2024-10-12T13:54:01.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>进程(process)和线程(thread)是操作系统的基本概念，但是因为前端工作中基本不会碰到，渐渐地也就遗忘了。<br>最近，因为一些事情又牵扯到它们了，网上也查阅了一些资料文章，所以写一篇博客总结记录一下。</p></blockquote><span id="more"></span><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>计算机的核心是CPU，它承担了所有的计算任务，输入算式，输出结果。</p><p>在这里为了便于下面理解，我们把它当成以前的<code>电话局</code>，<code>CPU核心</code>理解成电话局里的每一部电话机，用来让你跟其他人打电话沟通。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>线程</code>是操作系统能够进行运算调度的最小单位。上面说了，CPU是负责所有的计算任务的，所以这里，我们可以把线程当成“跟某个人打电话”这个任务。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><code>进程</code>是操作系统中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p><p>听起来很抽象对不对？回到上面的电话局打电话，早期电话还是稀罕物，打个电话都要跑老远到电话局的，不像现在家家一部电话、人人一部手机。阿强不可能只是为了跟阿珍说一句“早上好”就跑到电话局打电话对不对？一般都是把要跟哪些人打电话说什么都事先写好，到了电话局拨号、通话、结束、再拨号、再通话。。。如此重复。</p><p>打电话的这个人就是<code>线程</code>。因为电话局的电话只能分配给人，无法分配给<code>打电话</code>这个任务，所以<code>进程</code>是系统资源分配和调度的基本单位。</p><h3 id="线程、进程关系"><a href="#线程、进程关系" class="headerlink" title="线程、进程关系"></a>线程、进程关系</h3><p>结合上面的类比，我们可以轻松理解线程与进程关系。</p><p>线程是属于进程的，线程运行在进程空间内(<code>只有人可以携带打电话任务</code>)，同一进程所产生的线程共享同一内存空间(<code>一个人的所有打电话任务只能使用一部电话机</code>)，当进程退出时该进程所产生的线程都会被强制退出并清除(<code>人离开电话局后，打电话任务也就不存在了</code>)。</p><p>线程可与属于同一进程的其它线程共享进程所拥有的全部资源(<code>一个人的所有打电话任务只能使用一部电话机</code>)，但是其本身基本上不拥有系统资源(打电话任务自身无法申请电话机)，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p><h3 id="互斥锁-Mutual-exclusion，缩写-Mutex"><a href="#互斥锁-Mutual-exclusion，缩写-Mutex" class="headerlink" title="互斥锁(Mutual exclusion，缩写 Mutex)"></a>互斥锁(Mutual exclusion，缩写 Mutex)</h3><p>当你在通话时，你需要占用一条电话线路(<code>系统资源</code>)，你通话结束后就需要释放这条线路用于别人打电话。为了防止你正在通话过程中被人拔电话线，就需要让系统知道你这次通话开始或结束了。如何让系统知道你正在占用线路呢？就是拨号和挂断，拨号代表你开始占用线路，挂断代表你结束线路占用。</p><p>这里的拨号和挂断的行为就是<code>互斥锁</code>。上锁(<code>拨号</code>)代表进程(<code>打电话的人</code>)对某块内存区域(<code>电话线路</code>)的占用，其他进程(<code>其他打电话的人</code>)就无法操作这块内存区域，解锁(<code>挂断</code>)之后其它进程才可以使用这块内存。互斥锁是防止多个线程同时读写同一块内存区域。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;进程(process)和线程(thread)是操作系统的基本概念，但是因为前端工作中基本不会碰到，渐渐地也就遗忘了。&lt;br&gt;最近，因为一些事情又牵扯到它们了，网上也查阅了一些资料文章，所以写一篇博客总结记录一下。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机" scheme="https://dysdf.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="计算机" scheme="https://dysdf.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="操作系统" scheme="https://dysdf.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="进程" scheme="https://dysdf.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://dysdf.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
